import axios from 'axios';

export default async function handler(req, res) {
  const { username, theme = 'default', lang = 'pl' } = req.query;

  if (!username) return res.status(400).send('Brak username');

  try {
    const token = process.env.GITHUB_TOKEN;
    if (!token) return res.status(500).send('Brak tokena GitHub');

    // 1. Pobieramy repozytoria użytkownika (maksymalnie 100 ostatnich, niesforkowanych)
    // Używamy GraphQL, bo jest o wiele szybsze i pozwala pobrać języki w jednym zapytaniu
    const query = `
      query($user: String!) {
        user(login: $user) {
          repositories(first: 60, ownerAffiliations: OWNER, isFork: false, orderBy: {field: PUSHED_AT, direction: DESC}) {
            nodes {
              name
              languages(first: 10) {
                edges {
                  size
                  node {
                    color
                    name
                  }
                }
              }
            }
          }
        }
      }
    `;

    const response = await axios.post(
      'https://api.github.com/graphql',
      { query, variables: { user: username } },
      { headers: { Authorization: `bearer ${token}` } }
    );

    if (response.data.errors) throw new Error('GitHub API Error');

    const repos = response.data.data.user.repositories.nodes;

    // 2. Sumowanie bajtów dla języków
    const stats = {};
    let totalBytes = 0;

    repos.forEach(repo => {
      repo.languages.edges.forEach(lang => {
        const { name, color } = lang.node;
        const size = lang.size;

        if (!stats[name]) {
          stats[name] = { color, size: 0 };
        }
        stats[name].size += size;
        totalBytes += size;
      });
    });

    // 3. Przetwarzanie i sortowanie
    // Zamieniamy obiekt na tablicę, sortujemy malejąco i bierzemy TOP 5
    let languages = Object.entries(stats)
      .map(([name, data]) => ({
        name,
        color: data.color || '#ccc',
        size: data.size,
        percent: ((data.size / totalBytes) * 100).toFixed(1)
      }))
      .sort((a, b) => b.size - a.size)
      .slice(0, 6); // Top 6 języków

    // --- TŁUMACZENIA ---
    const i18n = {
        pl: {
          title: "Najczęściej używane języki",
          footer: "Wygenerowano przez MaxPowerPL"
        },
        en: {
          title: "Most Used Languages",
          footer: "Generated by MaxPowerPL"
        }
    };
    const txt = i18n[lang] || i18n['pl'];

    // 4. Motywy kolorystyczne (spójne z resztą)
    const themes = {
        default: { bg: '#1a1b27', stroke: '#00f2ff', text: '#ffffff', secondary: '#00f2ff' },
        gruvbox: { bg: '#282828', stroke: '#ebdbb2', text: '#ebdbb2', secondary: '#fabd2f' },
        dracula: { bg: '#282a36', stroke: '#bd93f9', text: '#f8f8f2', secondary: '#50fa7b' },
        light:   { bg: '#ffffff', stroke: '#0366d6', text: '#24292e', secondary: '#0366d6' },
        radical: { bg: '#141321', stroke: '#fe428e', text: '#a9fef7', secondary: '#fe428e' },
        merko:   { bg: '#0a0c10', stroke: '#abd200', text: '#68b587', secondary: '#abd200' },
        tokyonight: { bg: '#1a1b26', stroke: '#7aa2f7', text: '#38bdae', secondary: '#7aa2f7' }
    };
    const t = themes[theme] || themes['default'];

    // 5. Generowanie SVG
    // Obliczamy szerokość paska dla każdego języka
    let progressX = 0;
    const progressBarWidth = 350; // Szerokość całkowita paska w SVG

    const svg = `
      <svg width="400" height="180" viewBox="0 0 400 180" xmlns="http://www.w3.org/2000/svg">
        <style>
          /* Tytuł używa t.text (główny kolor) */
          .header { font: 600 18px 'Segoe UI', Ubuntu, Sans-Serif; fill: ${t.text}; }
          .lang-name { font: 400 13px 'Segoe UI', Ubuntu, Sans-Serif; fill: ${t.secondary}; }
          .lang-percent { font: 400 13px 'Segoe UI', Ubuntu, Sans-Serif; fill: ${t.text}; opacity: 0.8; }
        </style>

        <rect width="400" height="180" rx="10" fill="${t.bg}" stroke="${t.stroke}" stroke-width="2"/>

        <text x="25" y="35" class="header">${txt.title}</text>

        <g transform="translate(25, 55)">
          <mask id="bar-mask">
            <rect x="0" y="0" width="${progressBarWidth}" height="10" rx="5" fill="white" />
          </mask>
          ${languages.map(lang => {
             const width = (lang.size / totalBytes) * progressBarWidth;
             const rect = `<rect x="${progressX}" y="0" width="${width}" height="10" fill="${lang.color}" mask="url(#bar-mask)"/>`;
             progressX += width;
             return rect;
          }).join('')}
        </g>

        <g transform="translate(25, 85)">
          ${languages.map((lang, index) => {
            const col = index < 3 ? 0 : 170;
            const row = (index % 3) * 25;
            return `
              <g transform="translate(${col}, ${row})">
                <circle cx="5" cy="5" r="5" fill="${lang.color}" />
                <text x="15" y="9" class="lang-name">${lang.name}</text>
                <text x="120" y="9" class="lang-percent" text-anchor="end">${lang.percent}%</text>
              </g>
            `;
          }).join('')}
        </g>

        <text x="380" y="170" font-family="Segoe UI, Helvetica, Arial" font-size="11" fill="${t.text}" opacity="0.6" text-anchor="end">
          ${txt.footer}
        </text>
      </svg>
    `;

    res.setHeader('Content-Type', 'image/svg+xml');
    res.setHeader('Cache-Control', 's-maxage=3600, stale-while-revalidate'); // Cache na 1h
    res.status(200).send(svg);

  } catch (error) {
    console.error(error);
    res.status(500).send('Error generating top languages');
  }
}